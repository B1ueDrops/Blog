---
title: Rust系统总结
categories: 编程语言
mathjax: true
---



## 变量



### 栈/堆

* 基本类型的值存储在线程的栈上, 因为基本类型大小固定, 并且栈的存储/访问速度一般快.
  * 基本类型有: 整数, 浮点, 字符, 以及仅包含它们的元组.

* 非基本类型存储在堆上, 因为非基本类型一般大小在编译时期不固定, 在栈中会存储数据在堆中地址.



### 可变/不可变

* 对于一个变量, 如果你要修改它的某些值, 那么它就是可变变量, 需要用`mut`.



### 所有权

* 所有权是指**堆上数据的所有权**.

* 所有权的核心: **对于堆上的的数据, 仅可能通过一个变量去访问, 也就是一个堆上的值, 有且仅有一个ownership**.
  * 如果出现赋值语句, 函数参数传递, 或者函数返回值返回, 都会发生所有权的转移, 原变量会失效.
  * 对于基本类型数据, 在上述情况会发生时会对数据进行**深拷贝**, 原变量不会失效, 不会有所有权转移.
* 可以使用`clone()`函数对堆上的数据进行**深拷贝**, 并且返回新的存储地址.



### 引用

* 引用是对所有权的**租借(borrow)**, 也是实现**浅拷贝**的方法.

  * 无论你如何使用引用, 都不会改变原变量的所有权, 只有使用权.

* 引用是个变量, 本身具有可变/不可变两种类型:

  * 可变引用: 这个引用变量可以租借其他变量所有权.
  * 不可变引用: 这个引用变量只能租借一个变量的所有权.

* 引用有两种内置类型, 注意这里的类型与上面描述不同, type的描述词是`&T`和`&mut T`:

  * `&T`: 不可以通过修改引用来改变原变量的值.
  * `&mut T`: 可以通过修改引用修改原变量的值.
    * 原变量必须是可变变量(有`mut`).


  * 对于一个变量, 在同一生命周期内, 允许有多个`&T`引用, 但是**只能有一个`&mut T`引用.**
  * 引用本质上也是一种**非基本类型**, 并且**实现了Deref trait**, 因此能和普通变量一样使用, 不需要显式解引用. 



### 生命周期

* 变量在定义时, 生命周期就会固定.
* **堆上的数据是否被释放, 取决于它的所有权在哪个变量**, 变量生命周期过了就会被释放.

```rust
fn main() {
    let b;
    {
        let a = String::from("haha");
        // String::from本来在这个生命周期会被释放, 但是值的所有权转移后, 就不会被释放.
        b = a;
    }
    println!("{}", b);
}
```

* **最基本的生命周期约束:** 使用引用租借一个变量的所有权时, 需要保证**引用变量的生命周期小于等于原变量的生命周期**.





## 函数



### 生命周期约束

* 可以对引用进行生命周期的标注, 例如: `first: &'a i32`:

  * 标注的意思是: **这个引用所指向的原变量的生命周期是`a`**.

* **函数的生命周期约束: **如果函数返回值是**引用**, 那么**返回值引用指向的原变量**的生命周期, 要小于等于所有参数生命周期的最小值.

  * 函数如果返回引用, 那么这个引用只有两个来源:
    * 函数参数.
    * 函数内部新的变量的引用, 这种情况会出现Dangling Reference, 需要返回原变量, 让其发生所有权转移.

* **Rust消除生命周期标注的规则:**

  * 对于输入的每个引用, 都会分配一个生命周期标注:

    ```rust
    // 分配前
    fn foo(x: &i32, y: &i32);
    // 分配后
    fn foo<'a, 'b>(x: &'a i32, y: &'b i32);
    ```

  * 如果只有一个输入生命周期`a`, 并且函数返回值是引用, 那么返回值引用的生命周期也会被标注为`a`.

  * 如果存在多个输入生命周期, 但是其中有一个引用是`&self`或者是`&mut self`, 并且函数返回值是引用, 那么返回值引用的生命周期会和`&self/&mut self`标注的一样.

* 如果实际情况不符合生命周期标注规则, 那么就需要**手动标注**, 否则编译不通过:

  * 最典型情况: 函数参数有多个引用类型, 并且返回值也是引用类型.

    * 为什么这种情况需要标注?

      * 因为返回值引用必然依赖于函数参数引用, 但是可能函数在运行时才能决定依赖于那些参数引用, 例如这个例子:

        ```rust
        // 函数用来返回长度较长的字符串的引用, 具体返回哪个参数取决于运行时
        fn longest(x: &str, y: &str) -> &str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }
        ```

  * 怎么标注?

    ```rust
    fn longest<'a>(x: &'a str, y: &'a &str) -> &'a str {
      	if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    ```

    * 表示返回值的引用指向的原变量的生命周期, 和函数参数`x, y`具有相同的生命周期, 这才能通过编译.

* **最长的生命周期:** `'static`, 这个生命周期能和程序活得一样久.

  * 字符串字面值: `let s: &'static str = "我没啥优点，就是活得久，嘿嘿";`



## 面向对象



### 结构体

* 定义语法:

  ```rust
  // 最后没有;
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  ```

  



## 软件工程



### 权限

* Rust中, 很多元素都有权限, 这个权限是相对于其他mod说明的:
  * `pub`权限: 可以在其他mod中导入元素.
  * 不写`pub`: 就是private权限, 只可以在当前mod中使用权限.



### 多文件编程



### 集合类型



### 函数式编程



### 异常处理



### 单元测试

