---
title: 设计模式的实际操作
categories: 后端技术
---



## 系统的结构

* 系统有三个部分: Input, Executor, Output.
* 其中, Input, Executor可变, 需要通过设计模式增强代码的健壮性.



## Input设计



* 为所有Input设计一套通用接口, 不同Input实现接口, 实现时注意:
  * 成员变量在构造函数内部提供默认值, 如需修改在通用接口中提供Getter/Setter方法.
  * 在Executor中, 将Input接口类型作为成员变量.



## Executor设计

* Executor中, 除了Input之外的成员变量需要在**构造函数签名**处提供默认值.

* Executor可变可以分为不同类型:
  * Executor中某一个功能可变: **策略模式**
    * 为功能提供接口, 然后不同功能类实现接口, 然后用组合方式整合到Executor中.
  * Executor中工作流程可变: **模板方法模式**
    * 提供一个抽象类, 子方法留接口, 模板方法规定顺序.
    * 不同类实现抽象类中的子方法接口.
    * 模板方法对象用组合方式整合到Executor中.



> 策略模式的一个问题: 假设实现某个算法, 有多种方法, 多种方法需要的参数不同, 如何写保证代码质量? 如果实现这些方法需要父模块的一些信息呢?

* 需要的参数不同: 参数应该不暴露给用户, 方法内部应该自行确定.
* 需要父模块的信息: 这个时候, 继承更好, 让类变成抽象类, 父模块信息作为成员变量.

## 系统功能设计

### 观察者模式

* **使用场景:** Input到达之后, Executor中的状态需要改变.
* **实现方式:**
  * 提供观察者接口, 接口中的方法提供足量参数, 让状态更新自己.
  * Executor中需要改变的状态实现观察者接口.
  * 提供一个抽象类:
    * 抽象类中有列表成员变量, 存储所有需要改变状态的成分, 类型是观察者接口类型.
    * 抽象类中的方法需要让Executor更新所有观察者的状态.
  * Executor实现抽象类.