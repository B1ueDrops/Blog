---
title: 多进程/多线程编程模型
categories: 操作系统
---



## 锁

* **锁的本质是一个内存中的整数, 对这个整数的操作都是原子操作**.
  * 锁只能存储在内存中, 不能放到寄存器中(因为只有内存才可以在CPU之间共享, 寄存器一个CPU有一套).
  * 对锁进行操作, <font color=red>一定是通过指针去处理</font>, 不能通过变量名, 因为对指针的操作能够确保一定是访问内存.
    * 如果对变量名读写, 那么编译器优化后, 很可能通过寄存器读写.
  * **锁的实现:**
    * 锁的值如果是0, 表示当前没有线程上锁, 如果是1, 表示有线程上锁.
    * 当线程尝试获取锁时, 先让一个寄存器置1, 然后用CPU的原子指令把寄存器和锁内存交换.
    * 互换后, 判断寄存器的值:
      * 如果寄存器的值是0: 没有上锁, 可以读写共享数据.
      * 如果寄存器的值是1: 上锁了, 线程需要等待/让出时间片.
    * 线程释放锁时, 直接将锁的值赋值为0.
* **锁的分类**:
  * 自旋锁(spinlock): 进程获取锁失败后, 会一直轮训, 不会睡眠.
  * 互斥锁(mutex): 进程获取锁失败后, 可能会睡眠, 等待OS唤醒.
  * 在中断上下文中, 不能使用mutex, 因为中断需要快速处理, 不能睡眠.
  * spinlock一般用在内核多进程场景, mutex一般用在用户多线程场景.
