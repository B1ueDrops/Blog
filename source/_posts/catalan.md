---
title: 卡特兰数系列
categories: 算法
mathjax: true
---



## 满足条件01序列个数

> https://www.acwing.com/problem/content/description/891/

* 假设现在在一个坐标轴, 一个01序列表示一条运动轨迹, 0表示向右走, 1表示向上走, 那么这个问题就可以转化成从$(0, 0)$到$(n, n)$的路径中, 有多少路径在直线$y = x + 1$ 以下, 或者是不经过$y = x + 1$.

* 那么取一个补集, 也就是所有从$(0, 0)$走到$(n, n)$的方案, 减去经过直线$y = x + 1$的方案.
* 对于经过直线$y = x + 1$的所有方案, 假设这个路径和直线$y = x + 1$的交点是$(a, b)$, 那么这条路径从$(a, b)$到$(n, n)$这一段按照$y = x + 1$进行反转, 最终的终点就是$(n - 1, n + 1)$.
  * 也就是说, 每一条经过$y = x + 1$并且走到$(n, n)$的路径, 都和从$(0, 0)$走到$(n - 1, n + 1)$的路径一一对应.
* 那么最终方案就可以表示成: $C_{2n}^{n} - C_{2n}^{n-1} = \frac{C_{2n}^n}{n+1}$​, 这个数就是卡特兰数.



## n对括号组成的括号序列个数

同理, 有$n$对括号()组成的合法的括号序列的个数也是卡特兰数.



## n个节点组成的二叉树



### 转化成01序列

* 首先, 对于一颗由n个节点组成的二叉树, 我可以建立一个映射, 把它变成一个完全二叉树.
  * 对于原来的n个节点, 经过变换后都是父亲节点, 并且有两个儿子.
  * 这种映射是通过补充n+1个叶子节点实现的, 最终的完全二叉树有2n+1个节点.
  * 这种映射的逆映射是删除完全二叉树的所有叶子节点, 可以把一个2n+1个节点的完全二叉树变成一个n个节点组成的二叉树.
  * 这种映射是一种满射.

* 因此, 对于一个2n+1个节点的完全二叉树, 如果把所有左儿子当作0, 把所有右儿子当作1, 然后做不包含根节点的前序遍历, 那么最终得到的也是一个符合卡特兰数性质的01序列(因为前序遍历, 任何一个前缀中0一定比1多). 于是就可以转化成01序列问题.





## 按照动态规划

假设$f(n)$表示$n$个节点组成的二叉树的个数, 那么:

```cpp
vector<int> f(n + 1);
f[0] = 1;

for (int i = 1; i <= n; i ++) {
  // 遍历左子树有多少个节点
  for (int j = 0; j <= i - 1; j ++) {
    // 左子树和右子树是乘法原理
    f[i] = f[j] * f[i - 1 - j];
  }
}
```

所有符合这种递推式的方案数目, 都是卡特兰数.

卡特兰数前几个数:

* `f[0] = 1`.
* `f[1] = 1`.
* `f[2] = 2`.
* `f[3] = 5`.
* `f[4] = 14`.
* `f[5] = 42`.
