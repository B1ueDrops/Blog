---
title: 卡特兰数系列
categories: 算法
mathjax: true
---



## 满足条件01序列个数

> https://www.acwing.com/problem/content/description/891/

* 假设现在在一个坐标轴, 一个01序列表示一条运动轨迹, 0表示向右走, 1表示向上走, 那么这个问题就可以转化成从$(0, 0)$到$(n, n)$的路径中, 有多少路径在直线$y = x + 1$ 以下, 或者是不经过$y = x + 1$.

* 那么取一个补集, 也就是所有从$(0, 0)$走到$(n, n)$的方案, 减去经过直线$y = x + 1$的方案.
* 对于经过直线$y = x + 1$的所有方案, 假设这个路径和直线$y = x + 1$的交点是$(a, b)$, 那么这条路径从$(a, b)$到$(n, n)$这一段按照$y = x + 1$进行反转, 最终的终点就是$(n - 1, n + 1)$.
  * 也就是说, 每一条经过$y = x + 1$并且走到$(n, n)$的路径, 都和从$(0, 0)$走到$(n - 1, n + 1)$的路径一一对应.
* 那么最终方案就可以表示成: $C_{2n}^{n} - C_{2n}^{n-1} = \frac{C_{2n}^n}{n+1}$​, 这个数就是卡特兰数.



## n对括号组成的括号序列个数

同理, 有$n$对括号()组成的合法的括号序列的个数也是卡特兰数.



## n个节点组成的二叉树



### 转化成括号序列

首先, 先不看二叉树, 先看完全二叉树的定义:

* 完全二叉树除了最后一层, 其余层节点都是满的, 并且最后一层从左到右节点都是连续出现.



## 按照动态规划

假设$f(n)$表示$n$个节点组成的二叉树的个数, 那么:

```cpp
vector<int> f(n + 1);
f[0] = 1;

for (int i = 1; i <= n; i ++) {
  // 遍历左子树有多少个节点
  for (int j = 0; j <= i - 1; j ++) {
    f[i] = f[j] + f[i - 1 - j];
  }
}
```

所有符合这种递推式的方案数目, 都是卡特兰数.



